<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>SR Compatibility Response Time Test</title>

<style>
    body {
        font-family: Arial, sans-serif;
        text-align: center;
        background: #d9e3f0; /* light blue-gray */
        color: black;
        padding: 20px;
    }

    h1, h2 {
        color: #3f6ecf; /* medium blue headings */
    }

    #stimulus {
        width: 150px;
        height: 150px;
        border-radius: 50%;
        margin: 30px auto;
        display: none;
        box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }

    table {
        margin: 12px auto;
        border-collapse: collapse;
        background: #fafafa;
    }

    td, th {
        padding: 8px 12px;
        border: 1px solid black; /* black borders */
    }

    #countdown {
        font-size: 20px;
        margin-top: 12px;
        color: #333;
    }

    button {
        padding: 10px 18px;
        font-size: 16px;
        background: #4b79c9; /* medium blue */
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        margin-top: 10px;
    }

    button:hover {
        background: #3c63a8; /* darker blue hover */
    }

    .highlight {
        background: #c8f0c1 !important; /* green highlight */
    }
</style>
</head>

<body>

<h1>SR Compatibility Response Time Test</h1>

<div id="instructions">
    <h2>Instructions</h2>

    <p><strong>Condition A (Simple Mapping):</strong> Press the first letter of the circle’s color.</p>

    <table>
        <tr><th>Circle Color</th><th>Key to Press</th></tr>
        <tr><td>Red</td><td>R</td></tr>
        <tr><td>Blue</td><td>B</td></tr>
        <tr><td>Green</td><td>G</td></tr>
        <tr><td>Yellow</td><td>Y</td></tr>
    </table>

    <p><strong>Condition B (Complex Mapping):</strong> Use this altered color–key pairing.</p>

    <table>
        <tr><th>Circle Color</th><th>Key to Press</th></tr>
        <tr><td>Red</td><td>B</td></tr>
        <tr><td>Blue</td><td>G</td></tr>
        <tr><td>Green</td><td>Y</td></tr>
        <tr><td>Yellow</td><td>R</td></tr>
    </table>

    <p>You will complete:<br>
    • 1 practice trial for each condition (10 seconds each)<br>
    • A 15-second main trial for each condition<br>
    The circle only changes after you press the correct key. Practice trials are not included in the final averages.</p>

    <button onclick="SR_startExperiment()">Start Experiment</button>
</div>

<div id="countdown"></div>
<div id="stimulus"></div>
<div id="keyMappings"></div>
<div id="status"></div>

<script>
const SR_conditions = [
    "simple_practice",
    "simple_main",
    "complex_practice",
    "complex_main"
];

let SR_index = 0;
let SR_running = false;
let SR_isPractice = true;
let SR_startTime = 0;
let SR_expectedKey = "";
let SR_rtData = [];     
let SR_allData = [];    

const SR_colors = ["red","blue","green","yellow"];

const SR_simpleKeys = { red:"r", blue:"b", green:"g", yellow:"y" };
const SR_complexKeys = { red:"b", blue:"g", green:"y", yellow:"r" };

const instrDiv = document.getElementById("instructions");
const stimDiv = document.getElementById("stimulus");
const keyMapDiv = document.getElementById("keyMappings");
const countdownDiv = document.getElementById("countdown");
const statusDiv = document.getElementById("status");

function SR_startExperiment(){
    instrDiv.style.display = "none";
    SR_index = 0;
    SR_runNextCondition();
}

function SR_showKeyMappings(type){
    const map = (type === "simple") ? SR_simpleKeys : SR_complexKeys;
    let html = "<h3>Key Mappings</h3><table><tr><th>Color</th><th>Key</th></tr>";
    for (let c in map) html += `<tr id="row-${c}"><td>${c.charAt(0).toUpperCase() + c.slice(1)}</td><td>${map[c].toUpperCase()}</td></tr>`;
    html += "</table>";
    keyMapDiv.innerHTML = html;
}

function SR_startTransition(next){
    let sec = 5;
    countdownDiv.textContent = `Starting in ${sec}...`;
    let t = setInterval(() => {
        sec--;
        if (sec > 0) countdownDiv.textContent = `Starting in ${sec}...`;
        else {
            clearInterval(t);
            countdownDiv.textContent = "";
            next();
        }
    }, 1000);
}

function SR_runNextCondition(){
    stimDiv.style.display = "none";
    keyMapDiv.innerHTML = "";
    statusDiv.innerHTML = "";

    if (SR_index >= SR_conditions.length){
        SR_showFinalResults();
        return;
    }

    const cond = SR_conditions[SR_index];
    SR_isPractice = cond.includes("practice");

    let label = cond === "simple_practice" ? "Practice Trial — Condition A (Simple Mapping)"
              : cond === "simple_main"     ? "Main Trial — Condition A (Simple Mapping)"
              : cond === "complex_practice"? "Practice Trial — Condition B (Complex Mapping)"
              :                               "Main Trial — Condition B (Complex Mapping)";

    statusDiv.innerHTML = `<h2>${label}</h2>`;
    SR_showKeyMappings(cond.includes("simple") ? "simple" : "complex");

    SR_startTransition(() => {
        if (cond.includes("practice")) SR_startTrial(cond, 10000);
        else SR_startTrial(cond, 15000);
    });
}

let SR_trialTimer = null;
let SR_timeLeftTimer = null;

function SR_startTrial(cond, duration){
    countdownDiv.textContent = "";

    stimDiv.style.display = "block";
    keyMapDiv.style.display = "block";
    SR_running = true;

    SR_presentStimulus(cond);

    let endTime = Date.now() + duration;
    countdownDiv.textContent = `Time left: ${Math.ceil((endTime - Date.now())/1000)} sec`;

    SR_timeLeftTimer = setInterval(() => {
        const secs = Math.max(0, Math.ceil((endTime - Date.now())/1000));
        countdownDiv.textContent = `Time left: ${secs} sec`;
        if (secs <= 0) clearInterval(SR_timeLeftTimer);
    }, 250);

    SR_trialTimer = setTimeout(() => {
        SR_endTrial(cond);
    }, duration);
}

function SR_presentStimulus(cond){
    const color = SR_colors[Math.floor(Math.random()*SR_colors.length)];
    stimDiv.style.background = color;
    SR_expectedKey = cond.includes("simple") ? SR_simpleKeys[color] : SR_complexKeys[color];
    SR_startTime = performance.now();
}

document.addEventListener("keydown", (ev) => {
    if (!SR_running) return;

    const key = ev.key.toLowerCase();
    if (key !== SR_expectedKey) return;

    const rt = performance.now() - SR_startTime;

    SR_allData.push({
        condition: SR_conditions[SR_index],
        practice: SR_isPractice,
        rt: rt
    });

    if (!SR_isPractice) SR_rtData.push({ condition: SR_conditions[SR_index], rt: rt });

    let cMap = SR_conditions[SR_index].includes("simple") ? SR_simpleKeys : SR_complexKeys;
    let colorName = Object.keys(cMap).find(k => cMap[k] === key);
    if (colorName) {
        const row = document.getElementById(`row-${colorName}`);
        if (row) {
            row.classList.add("highlight");
            setTimeout(() => row.classList.remove("highlight"), 300);
        }
    }

    SR_presentStimulus(SR_conditions[SR_index]);
});

function SR_endTrial(cond){
    SR_running = false;
    stimDiv.style.display = "none";
    clearInterval(SR_trialTimer);
    clearInterval(SR_timeLeftTimer);
    countdownDiv.textContent = "";

    if (!SR_isPractice) {
        const filtered = SR_rtData.filter(d => d.condition === cond).map(d => d.rt);
        const avg = filtered.length ? (filtered.reduce((a,b)=>a+b,0)/filtered.length).toFixed(2) : "No responses";
        statusDiv.innerHTML += `<p><strong>Average Reaction Time:</strong> ${avg} ms</p>`;
    } else {
        statusDiv.innerHTML += `<p><em>Practice trial complete (not included in averages).</em></p>`;
    }

    SR_index++;
    setTimeout(() => SR_runNextCondition(), 5000);
}

function SR_showFinalResults(){
    const simpleArr = SR_rtData.filter(d => d.condition === "simple_main").map(d => d.rt);
    const complexArr = SR_rtData.filter(d => d.condition === "complex_main").map(d => d.rt);

    const mean = arr => arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(2) : "No responses";

    document.body.innerHTML = `
        <h1>Results</h1>
        <p><b>Simple Mapping Mean RT:</b> ${mean(simpleArr)} ms</p>
        <p><b>Complex Mapping Mean RT:</b> ${mean(complexArr)} ms</p>
        <button onclick="SR_downloadCSV()">Download CSV</button>
        <p><em>Practice trials were excluded from averages.</em></p>
    `;
}

function SR_downloadCSV(){
    let csv = "condition,rtn";
    SR_rtData.forEach(r => csv += `${r.condition},${r.rt}n`);
    const blob = new Blob([csv], {type: "text/csv"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "sr_compatibility_main_trials.csv";
    a.click();
}
</script>
</body>
</html>




